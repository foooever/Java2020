## JVM
### 1.内存泄漏
Java的重要特性之一就是有GC自动进行垃圾回收内存管理，而不用程序员自己手动释放（相比c++），但
任然会发生内存泄漏。

***Java的内存泄漏指的是不会再被使用的对象不能被回收，内存泄漏是内存溢出的主要原因。***

主要和对象的生命周期有关，若长生命周期的对象持有短生命周期的引用，则可能出现内存泄漏。可以
缩小变量的作用域或手动null。
```Java
public class Simple {
 
    Object object;//只作用于method1
 
    public void method1(){
        object = new Object(); //此时object的生命周期与Simple对象相同
    //...其他代码
    }
}//手动将object = null； //help gc
```
* 容器的内存泄露，`list`对象`pop()`后没有置为`null`，使得不再使用的位置仍有引用；
* 集合，`close()`方法未及时调用造成的；
* 单例模式，单例对象是长生命周期对象。

`finalize()`是`Object`类中的方法，在GC准备释放对象空间时，先调用其`finalize()`方法，
并在下一次GC回收发生时才真正回收。
### 2.内存管理
Java的内存管理主要是对运行时数据区的管理，管理的主要方法是垃圾回收GC，针对的主要区域是
堆，GC垃圾处理清理不再被使用的对象，如何对对象进行判活？

#### 2.1对象判活
* 引用计数法：给每个对象一个引用计数器，当有对象引用它时计数器+1，引用失效时-1，当计数器为0对象不在被引用，
可以进行清理；缺点：难以解决循环引用问题；
* 可达性分析，通过一系列`GC Roots`的对象作为起始点，进行搜索，搜索的路径称之为引用链，当一个对象
到`GC Roots`没有任何引用链相连，即为不可达对象，则此对象不可用，可进行GC；可作为`GC Roots`对象：
	* 栈中引用的对象；
	* 方法区中类static静态属性引用对象
	* 方法区中final常量引用对象；
	* 本地方法栈中JNI引用对象。

## 3.内存泄露和内存溢出
内存泄漏是内存溢出的最主要原因。内存溢出是OOM异常，通俗来说就是内存不够，当程序所需要内存远远超出JVM内存所承受大小。
* 大量死循环和方法无限递归调用--堆栈溢出；
* 大量循环产生新对象，无限分配内存空间；
* 集合类中对对象引用未及时清空（置null手动gc），内存泄露；
* 一次性读入过多的数据。

## 4.Java的内存模型（JMM）
### 4.1CPU和缓存一致性
当程序在运行过程中，会将运算需要的数据（变量）从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据
和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。

CPU的三级缓存：L1>L2>L3>内存（速度），每级缓存80%命中；当CPU要读取一个数据时，首先从一级缓存中查找，如果没有找到再从二级缓存中查找，
如果还是没有就从三级缓存或内存中查找。

在多核cpu多线程的情况下，每个核至少一个L1缓存，多线程访问进程中某个共享内存时，且多线程在不同的核上执行，则每个核会在缓存中保留一份
共享内存的缓冲，此时多线程进行写操作，会造成***缓存不一致问题***。

此外还有处理器优化和指令重排序问题。
### 4.2并发编程多线程会出现的问题
* 原子性问题：指一个操作中cpu不可中途暂停然后再调度，要么执行完成要不就不执行；处理器优化会导致原子性问题
* 可见性问题：当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程应该立即能看到修改的值；缓存一致性问题会导致可见性问题的发生
* 有序性问题：程序执行顺序按照代码的先后顺序执行；flag = true; a = 1会重排序造成程序逻辑错误；指令重排序会导致有序性问题
### 4.3Java内存模型
为了保证共享内存的正确性（可见性、有序性、原子性），**内存模型定义了共享内存系统中多线程程序读写操作行为的规范**。通过这些规则来规范对内存的读
写操作，从而保证指令执行的正确性。它与处理器有关、与缓存有关、与并发有关、与编译器也有关。他解决了CPU多级缓存、处理器优化、指令重排
等导致的内存访问问题，保证了并发场景下的一致性、原子性和有序性。

**Java的内存模型**是解决多线程场景下并发问题的一个重要规范，定义了共享内存中多线程程序读写操作行为的规范，Java内存模型规定所有变量存储在
主内存中，每个线程还有自己的工作内存，线程的工作内存中保存该线程中用到的变量的主内存副本拷贝，线程对变量的所有操作必须在工作内存中进行，
而不能直接读写主内存，不同线程之间无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。

Java内存模型除了定义了规范外，还提供了一系列原语，封装底层实现可供开发者使用，volatile、synchronized、final、concurrent包等；
* 原子性：synchronized，通过monitor
* 可见性：volatile关键字修饰变量在被修改后可以立即同步到主内存，被修饰的变量每次使用之前都是从主内存刷新，synchronized和final也可实现可见性；
* 有序性：volatile禁止指令重排序，synchronized保证同一时刻只允许单个线程进行操作。

内存间交互操作
* lock：作用于主内存的变量，把变量标识为一条线程独占的状态
* unlock：作用于主内存变量，把一个处于锁定状态的变量释放出来
* read：主内存变量值传输到线程的工作内存中，load动作使用
* load：作用于工作内存变量，把read操作从主内存中得到的变量放入工作内存变量副本中
* use：工作内存操作取变量
* assign：赋值将操作后的值赋给工作内存变量
* store：将工作内存变量传递到主内存中便于后write操作
* write：把store操作从工作内存得到变量放入主内存变量

### volatile
修饰的变量每次写入前刷新值，使得读操作在所有线程中是一致的，因此基于volatile变量的运算在并发下是安全的。
但有其应用场景
* 对volatile变量的运算结果并不依赖变量的当前值`volatile i; i++多线程情况下会出现不一致问题，在取volatile情况下多线程相同，但在修改的时候volatile变量更新了值过期了`，或者确保只有单一的线程修改变量的值；
* 变量不需要与其他的状态变量共同参与不变约束
* volatile变量禁止指令重排序，通过内存屏障禁止指令重排
### 4.4指令重排序
指令重排置在程序执行过程中，为性能考虑，编译器和CPU可能会对指令重新排序，一条汇编指令执行可以分为很多步骤。
对没有依赖的指令进行重排序，as-if-serial规则。

IF（取指）、ID（译码和取操作数）、EX（ALU计算单元）、MEM（存储器访问）、WB（写回寄存器）。

指令执行是流水线执行，后面的指令执行可能需要前面指令执行完成才可，会有等待过程，可进行指令重排序；

a = b + c; d = e - f;
* LW Rb b-IF ID EX MEM WB
* LW Rc c----IF ID EX MEM WB
* ADD Ra,Rb,Rc-IF ID ? MEM WB // ?需要等待前面指令的完成
* SW a Ra //等待Rc的取值ID
* LW Re e //此处仍要等待可通过指令重排放到前面执行

### 4.5Happen-Before先行发生原则
光靠synchronized和volatile保证程序执行过程的正确性（原子性、可见性、有序性）会很繁琐，Happen-Before规则约束数据之间是否存在竞争，
线程环境是否安全。保证先于发生的操作结果对后一操作可见。
* 顺序原则：一个线程保证语义串行性；a = 1; b = a + 1;前面操作的结果对后面操作可见，并非一定要先于执行
* volatile:volatile变量的写先发生于读；monitor
* 锁规则：解锁unlock先于加锁lock；
* 传递性：A先于B，B先于C，那么A必然先于C；
* 线程启动、中断、停止：start()方法先于它每一个动作，interrupt()先于被中断线程的代码，线程所有操作先于线程终结Thread.join()；
* 对象：对象构造函数先于finalize()方法。

### 4.6线程安全的实现方法
1.互斥同步

互斥实现同步，临界区、互斥量、信号量主要实现方式。`synchronized`关键字经过编译后，会在同步块的前后形成`monitorenter/monitorexit`字节码指令，
`synchronized`指定对象参数(对象-锁对象；`synchronized`修饰实例方法获取对象实例，类方法获取Class对象)。

JUC包中的`ReentrantLock`重入锁`lock()/unlock()`JDK1.6后synchronized优化过了，性能基本持平
* 等待可中断：等待线程长期得不到锁放弃等待
* 可实现公平锁：FIFO，多个进程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁
* 可以绑定多个condition对象

2.非阻塞同步

互斥同步主要代价是线程阻塞和线程唤醒所带来的性能问题，称为阻塞同步，互斥同步是一种悲观的并发策略。

乐观锁：基于冲突检测的乐观并发策略，先进行操作，如果没有线程争用共享数据，操作就成功了；如果有共享争用发生冲突，就不断地重试。

CAS指令：三个操作数，V,A,B，V表示内存位置（Java内存地址），旧的预期值A，新值B，CAS指令执行时，当且仅当V符合预期值A时才更新
V为B值，否则不更新，无论如何返回V的旧值，原子操作。

ABA问题，CAS操作时V的旧值A被改为B又改回了A，检查的时候仍然为A值，CAS操作成功。

3.锁优化

自旋锁：线程请求锁发现其被其他线程持有时，不进入阻塞状态而是循环等待，JDK1.5默认自旋10次，JDK1.6变为自适应自旋，由前一次在同一个锁
上的自旋时间。

轻量级锁：代码进入同步块时，如果此时同步对象没有被锁定`lock:01`，虚拟机首先将在当前线程栈帧中建立名为锁记录的空间`lock record`，
用于存储锁对象当前`mark word`的拷贝；然后虚拟机使用CAS操作尝试对对象`Mark word`更新指向`Lock record`，如果更新操作成功，则
该线程持有这个对象的锁，所标志位`lock:00`，表示轻量级锁定状态；更新失败，首先检查`Mark word`是否指向栈帧中，如果指向表明当前
线程已经持有这个对象锁，可以直接进入同步块执行（可重入对同一个线程）；否则表明该对象锁被其他对象持有，升级为重量级锁`lock:10`，
`Mark word`指向重量级锁的指针，互斥阻塞，等待线程进入阻塞状态。

轻量级锁解锁：CAS操作，把栈帧的拷贝的`Mark word`替换回来，成功则同步完成，不成功表明有其他线程尝试获取锁，则在释放锁同时唤醒被挂起线程。

偏向锁：无竞争的情况下把同步消除，CAS操作都没有，偏向第一个获取它的线程，在接下来的执行过程中若没有其他线程获取，则持有偏向锁的
线程永远不需要进行同步互斥。`lock:01/baised:1`   

## 5.类加载
Java虚拟机把所描述的类的数据从class文件加载到内存，并对数据进行校验，解析和初始化，最终形成可被虚拟机直接使用的Java类型。
* 1.加载：通过全限定类名来获取定义此类的二进制字节流文件.class文件；将字节流所代表的静态存储结构转化为方法区的运行时数据结构；
在内存（堆）中生成一个代表该类的java.lang.class对象，作为方法去这个类的访问入口；
* 2.验证：验证class文件的正确性，符合JVM的要求；
* 3.准备：为类变量（静态变量static）分配内存并设置类变量初始值；
* 4.解析：JVM将常量池中的符号引用替换成直接引用的过程；
* 5.初始化：对静态变量和静态代码块执行初始化工作。{new/static操作/反射/父类/主类启动}。

### **类加载器**
把实现类加载阶段“通过类全限定名获取二进制字节流文件的代码块”称为类加载器。
* 启动类加载器Bootstrap ClassLoader用来加载Java核心类库，无法被Java程序直接引用Java_HOME/lib/目录
* 扩展类加载器Extensions ClassLoader用来加载Java的扩展库，Java虚拟机的实现会提供一个扩展库目录，\lib\ext
* 系统类加载器System ClassLoader根据Java应用类路径加载Java类，（基本由它加载），ClassLoader.getSystemClassLoader()来获取它
* 用户自定义类加载器，通过继承java.lang.ClassLoader类的方式实现@override findClass()

### **双亲委派模型**
当一个类收到类加载请求时，不会自己先去加载这个类，二视将其委派给父类加载器，每一层次的类加载器都是如此，最后会传送至
启动类加载器Bootstrap ClassLoader，只有当父类加载器反馈自己无法完成这个类加载请求时，子类才会去完成类加载。

为什么采取双亲委派？

JVM为保证对象的唯一性采取的双亲委派模型，当两个对象都是用同名的类完成实例化的，并且对应的类加载器必须是同一个，若两个相同名字的类一个采用
系统类加载器加载，另一个采用扩展类加载器加载，则这两个类生成的对象将被JVM认定为不同类型的对象，所以为保证系统类安全，如java.lang.Object这种核心类，
JVM需要保证他们生成的对象被认定为同一种类型，通过代理模式，对于Java核心库的类的加载工作由启动类加载器统一完成，保证Java应用所使用的
都是同一版本Java核心库的类。

双亲委派的逻辑？

首先判断是否加载.class(Class c = findLLoadedClass(name))->若未加载，寻找父类类加载器，若不为null(不是Bootstrap ClassLoader)；使用父类加载器加载(也会向上委派至Bootstrap ClassLoader)->
父类进行类加载，若不成功->给子类加载ClassNotFoundException->进行解析，将符号引用替换成直接引用。